---
title: "http三次握手、四次挥手总结"
date: 2019-04-02
categories: 网络
description: http三次握手、四次挥手等
tags: 
- 网络
- 前端

---

### 三次握手

##### 首先刚开始时客户端处于closed状态，服务端处于listen状态。然后

1. 第一次握手：客户端发送SYN报文，并指明客户端的初始序列号ISN（c），然后客户端就处于SYN_send状态。
2. 第二次握手：服务端收到后，同样会发送一个SYN报文，以及自己的初始序列号ISN（s），同时还会将客户端的ISN+1作为ACK发送客户端，表明自己收到了客户端的报文。发送完成后，服务端处于SYN_REVD状态。
3. 第三次握手：客户端收到SYN后，验证ACK是否为ISN（c）+1，同时发送ISN（s）+1作为自己的ASK报文发送给客户端，此时客户端单方面进入了established状态。
4. 服务端收到ack报文后，确认ack=ISN（s）+1，处于established状态。

<!--more-->

> 为什么需要三次握手？
>
> 第一次握手，客户端发送SYN和初始ISN，服务端接收到之后，此刻**服务端可以确认客户端的发送能力**和**服务端（自己）的接受能力**。
>
> 第二次握手，服务端接收到了SYN和ISN，并将ISN+1作为ACK发走，客户端拿到了ack后，**客户端可以确认客户端（自己）的发送能力和接受能力，以及服务端的接受、发送能力，即可以确认此次网络请求一切正常。但是此时，服务端无法确认自己的发送能力和客户端的接受能力**
>
> 第三次握手，服务端接收到了ack报文，确认了客户端接受能力和自身的发送能力，此时双方都能确认双方各自的发送接受能力，连接正式建立。

### 四次挥手

##### 首先刚开始双方都处于established状态

1. 第一次挥手，首先客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端会处于FIN_WAIT状态。
2. 第二次挥手，服务端接收到FIN后，会将FIN中的序列号+1作为ACK报文发送给客户端，表明自己已经收到了断开连接的请求，此时服务端将处于CLOSE_WAIT状态。
3. 第三次挥手：如果服务端也想断开连接，会向第一次挥手一样，发送一个FIN状态并指定一个序列号。然后服务端将处于LAST_ACK状态。
4. 第四次挥手：同样，客户端接受到后，将FIN中的序列号+1作为ACK发送给服务端，此时客户端处于TIME_WAIT状态，需要过一阵子后确认服务端收到自己的ACK报文后，才会进入CLOSED状态。
5. 服务端收到ACK报文后，就处于CLOSED状态。

> 为什么第四次挥手的时候，客户端处于time-wait状态而不是关闭？
>
> 因为客户端要确保服务端收到ack报文，服务端在第三次挥手后，如果没有收到报文，会再次发送FIN报文，客户端接受到之后，就能知道之前的ACK报文丢失，会再次发送。

> 为什么握手三次，挥手四次？
>
> 建立连接时，服务端收到客户端的SYN报文，可以直接发送SYNACK报文。
>
> 但是关闭时，服务端收到FIN报文，很可能并不会关闭连接，所以只能先回复一个ACK表明自身收到了。等到服务端所有报文发送完成，才能发送FIN。因此不能一次全部发送。



